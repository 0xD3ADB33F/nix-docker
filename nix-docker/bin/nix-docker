#!/usr/bin/env node

var argv = require("optimist").argv;
var fs = require("fs");
var path = require("path");

var rootPath = path.resolve(fs.realpathSync(process.argv[1]), "../..");

var spawn = require('child_process').spawn;
var execFile = require('child_process').execFile;
var configFile = argv.c || "configuration.nix";
var fullBuild = !!argv.b;

var baseImage = argv.from || "zefhemel/base-nix";
var imageName = argv.t || "nix-docker-build";

var nixClosureCopy = "nix-closure";

if (argv.help) {
    console.log("Usage: nix-docker [-b] [-t imagename] [-c configuration.nix] ");
    console.log("   -b: build full (portable) docker image.");
    console.log("   -t: name of the image to build.");
    console.log("   -c: path to configuration file to build.");
    process.exit(0);
}

function pipeRun(cmd, args, callback) {
    var command = spawn(cmd, args);
    process.stdin.pipe(command.stdin);
    command.stdout.pipe(process.stdout);
    command.stderr.pipe(process.stderr);

    command.on('close', function(code) {
        callback(code);
    });
}

function build(nix, configPath, callback) {
    var nixBuild = spawn('nix-build', [nix, '-I', 'configuration=' + configPath, "--arg", "mountBuild", "" + !fullBuild, "--argstr", "name", imageName, "--argstr", "baseImage", baseImage, "--show-trace"].concat(fullBuild ? ["--no-out-link"] : []));
    var nixPath;

    nixBuild.stdout.on('data', function(data) {
        nixPath = data.toString("ascii");
    });
    nixBuild.stderr.pipe(process.stderr);

    nixBuild.on('close', function(code) {
        if (code === 0) {
            callback(null, nixPath.trim());
        } else {
            callback(code);
        }
    });
}

function cleanup(callback) {
    if(!fullBuild) {
        return callback();
    }
    if (!fs.existsSync(nixClosureCopy)) {
        return callback();
    }
    pipeRun("rm", ["-rf", nixClosureCopy], callback);
}

function buildImage(dockerFilePath, callback) {
    var dockerFile = fs.readFileSync(dockerFilePath + "/Dockerfile").toString("ascii");
    fs.writeFileSync("Dockerfile", dockerFile);
    pipeRun("docker", ["build", "-rm=true", "-t", imageName, "."], function(code) {
        cleanup(function() {
            callback(code);
        });
    });
}

function getAvailableNixPaths(callback) {
    var command = spawn("docker", ["run", baseImage, "/bin/ls", "/nix/store"]);
    process.stdin.pipe(command.stdin);

    var output = '';

    command.stdout.on("data", function(data) {
        output += data.toString("ascii");
    });

    command.on('close', function() {
        callback(null, output.split("\n"));
    });
}

function copyClosureAndBuild(dockerFilePath, availablePaths) {
    execFile("nix-store", ["-qR", dockerFilePath], {}, function(err, stdout) {
        if (err) {
            return console.error(err);
        }

        if (fullBuild) {
            var paths = stdout.trim().split("\n");
            paths = paths.filter(function(path) {
                return availablePaths.indexOf(path.substring("/nix/store/".length)) === -1;
            });

            console.log("New paths to copy", paths);

            fs.mkdirSync(nixClosureCopy);
            execFile("cp", ["-r"].concat(paths).concat([nixClosureCopy]), function(err) {
                pipeRun("chown", ["-R", "root:root", nixClosureCopy], function() {
                    if (err) {
                        console.log(err);
                        process.exit(1);
                    }
                    buildImage(dockerFilePath, function(code) {
                        console.log("To run: sudo docker run -t -i " + imageName);
                        process.exit(code);
                    });
                });
            });
        } else {
            buildImage(dockerFilePath, function(code) {
                console.log("To run: sudo docker run -t -i -v /nix/store:/nix/store " + imageName);
                process.exit(code);
            });
        }
    });
}

if(fullBuild && process.env.USER !== "root") {
    console.error("When doing a full build you need to run nix-docker as root. Rerun this command with 'sudo -E nix-docker ...'");
    process.exit(1);
}
cleanup(function() {
    build(rootPath + "/docker.nix", configFile, function(code, dockerFilePath) {
        if(code) {
            process.exit(code);
        }
        if (fullBuild) {
            getAvailableNixPaths(function(err, availablePaths) {
                copyClosureAndBuild(dockerFilePath, availablePaths);
            });
        } else {
            console.log("Result in", dockerFilePath, "test with sudo ./result/sbin/docker-run");
            console.log("To deploy: nix-copy-closure " + dockerFilePath + " machine  && ssh root@machine" + dockerFilePath + "/sbin/docker-run")
        }
    });
});